
=pod

=head1 COPYRIGHT

# (C) 1992-2018 Intel Corporation.                            
# Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack words    
# and logos are trademarks of Intel Corporation or its subsidiaries in the U.S.  
# and/or other countries. Other marks and brands may be claimed as the property  
# of others. See Trademarks on intel.com for full list of Intel trademarks or    
# the Trademarks & Brands Names Database (if Intel) or See www.Intel.com/legal (if Altera) 
# Your use of Intel Corporation's design tools, logic functions and other        
# software and tools, and its AMPP partner logic functions, and any output       
# files any of the foregoing (including device programming or simulation         
# files), and any associated documentation or information are expressly subject  
# to the terms and conditions of the Altera Program License Subscription         
# Agreement, Intel MegaCore Function License Agreement, or other applicable      
# license agreement, including, without limitation, that your use is for the     
# sole purpose of programming logic devices manufactured by Intel and sold by    
# Intel or its authorized distributors.  Please refer to the applicable          
# agreement for further details.                                                 


=cut

package acl::Simulator;
require acl::Common;
require acl::Env;
require acl::File;
require acl::AOCDriverCommon;

@ISA        = qw(Exporter);
@EXPORT     = ();
@EXPORT_OK  = qw(
    set_sim_debug
    set_sim_debug_depth
    set_sim_accurate_memory
    set_sim_kernel_clk_frequency
    set_sim_enable_warnings
    get_sim_package
    get_sim_options
    opencl_create_sim_system
    compile_opencl_simulator
    write_sim_repackage_script
);

use strict;


my $module = 'acl::Simulator';

=head1 NAME

acl::Simulator - Simulator utilities

=head1 VERSION

$Header: //acds/rel/18.1/acl/sysgen/lib/acl/Simulator.pm#3 $

=head1 SYNOPSIS


=head1 DESCRIPTION

This module provides utilities for create the OpenCL and HLS simulation framework.

All methods names may optionally be imported, e.g.:

   use acl::Simulator qw( compile_opencl_simulator );

=head1 METHODS

=cut

# Simulation options set by user
my $sim_debug = 0;    # 1 means add elaboration option to output vsim.wlf when running the simulation
                      # 0 means no waveform to speed up running time and reduce diskspace usage (default)
my $sim_debug_depth = undef;  # sets the hierarchy depth to capture into vsim.wlf. Applicable when $sim_debug=1
                              # Special case is undef, it means capture all, set with only -ghdl flag with no depth #
my $sim_accurate_memory = 0;
my $sim_kernel_clk_frequency = 400;  # in MHz
my $sim_enable_warnings = 0;  # 0 means suppress missing ports and parameter warnings

my $qsys_temp_dir = "aoc_msim.temp";     # default directory of less-QSys generated simulation harness
my $qsys_temp_dir_path = undef;          # absolute directory path name to simulation folder
my $sim_compile_script_name = "msim_compile.tcl";  # default to Modelsim filename
my $fname_exe_com_script = acl::Env::is_linux() ? 'compile.sh' : 'compile.cmd';   # for repackaging to invoke

# Compilation flow used. 3 levels of QSys:
#  1) Whole simulation framework is generated by QSys - existing simulation framework
#  2) Only the simulation board is generated by QSys  - SDK provide default with skip QSys for kernel system
#  3) Only the kernel_system is generated by QSys     - vendor board sim with QSys-less flow, i.e. S10
my $board_qsys = 0;         # 1: whole simulation framework; 0: simulation board only
my $kernel_system_qsys = 0; # 1: not currently supported

# Simulation Working Directory and top name
my $sim_qsys_name = "mpsim";          # QSys project name, match with aoc_sim_generate_qsys.tcl, to be bundle up into aocx
my $sim_dir = $sim_qsys_name."/sim";  # also define it as $QSYS_SIMDIR
my $sim_script_dir = $sim_dir;          # location of the generated compile and run scripts. 
                                        # With ModelSim: Qsys sim directory == compile directory, but VCSMX is different
# QSys infrastructure generates $QSYS_SIMDIR to put all the sim scripts and the RTL and files are located in ip/$QSYS_SIMDIR
my @sim_package = ('ip');       # for adding files and directories to aocx
my $kernel_system_inst = "ks";

sub set_sim_debug($) {
  $sim_debug = shift;
}

sub set_sim_debug_depth($) {
  $sim_debug_depth = shift;
}

sub set_sim_accurate_memory($) {
  $sim_accurate_memory = shift;
}

sub set_sim_kernel_clk_frequency($) {
  $sim_kernel_clk_frequency = shift;
}

sub set_sim_enable_warnings($) {
  $sim_enable_warnings = shift;
}

sub set_sim_dir_path($) {
  my $sim_path = shift;
  if (!defined($sim_path)) {
    # user did not provide a path, use default aoc_msim.temp
  	$sim_path = $qsys_temp_dir;
  }
  $qsys_temp_dir_path = acl::File::abs_path($sim_path);
  acl::Common::mydie("User specified simulation directory ${sim_path} does not exist: $!") if (! (-e $qsys_temp_dir_path));
  $qsys_temp_dir = acl::File::mybasename($qsys_temp_dir_path);
}

sub get_sim_package {
  return @sim_package;
}

sub get_sim_options {
  return "sim_options.txt";
}

# TODO: case:521549: Commonize i++ simulation subroutine to Simulator.pm
sub query_raw_vsim_version_string() {
    my $vsim_version_string = `vsim -version`;
    my $error_code = $?;

    if ($error_code != 0) {
      acl::Common::mydie("Error accessing ModelSim.  Please ensure you have a valid ModelSim installation on your path.\n" .
                  "       Check your ModelSim installation with \"vsim -version\" \n"); 
    }

    return $vsim_version_string;
}

# TODO: case:521549: Commonize i++ simulation subroutine to Simulator.pm
sub query_vsim_version_string() {
    my $vsim_simple_str = query_raw_vsim_version_string();
    $vsim_simple_str =~ s/^\s+|\s+$//g;
    return $vsim_simple_str;
}

# TODO: case:521549: Commonize i++ simulation subroutine to Simulator.pm
sub query_vsim_arch() {
    my $vsim_version_str = query_raw_vsim_version_string();
    my $cosim_64bit = ($vsim_version_str =~ /64 vsim/);
    return $cosim_64bit;
}

# Not exported. Create a simulation setup script with an updated library path that's relative
# to where the host invoke it
# TODO: case:521549: Commonize i++ simulation subroutine to Simulator.pm
sub _create_host_msim_setup_file($) {
  my $filepath = shift;
  my $file = $filepath.'/mentor/msim_setup.tcl';
  my $outfile = $filepath.'/mentor/msim_setup_host.tcl';
  open(FILE, "<$file") or acl::Common::mydie("Can't open $file for read");
  my @lines;
  while(my $line = <FILE>) {
    # fix library paths
    $line =~ s|\./libraries/|$sim_dir/libraries/|g;
    # fix vsim version call because it does not work in batch mode
    $line =~ s|\[\s*vsim\s*-version\s*\]|\$VSIM_VERSION_STR|g;
    push(@lines,$line);
  }
  close(FILE);
  open(OFH,">$outfile") or acl::Common::mydie("Can't open $outfile for write");
  foreach my $line (@lines) {
    print OFH $line;
  }
  close(OFH);
  return 0;
}

=head2 generate_simulation_scripts()

This module creates a file:
Moved everything into one file to deal with run time parameters, i.e. execution directory vs scripts placement.
Previous do scripts are rewritten to strings that gets put into the run script
 - compile_do      (the string run by the compilation phase, in the output dir)
 - simulate_do     (the string run by the simulation phase, in the output dir)

=cut

# TODO: case:521549: Commonize i++ simulation subroutine to Simulator.pm
sub generate_simulation_scripts() {
    # vsim version
    my $vsim_version_string = query_vsim_version_string();

    # Library names
    # OpenCL specific setups
    # OpenCL cosim libraries
    my $cosimlib = query_vsim_arch() ? 'aoc_cosim_msim' : 'aoc_cosim_msim32';
    # Script filenames
    my $fname_compilescript = $sim_script_dir.'/'.$sim_compile_script_name;
    my $fname_runscript = $sim_script_dir.'/msim_run.tcl';
    my $sdk_root_name = acl::Env::sdk_root_name();
    my $fname_svlib = acl::Env::sdk_root() . (acl::Env::is_linux() ? "/host/linux64/lib/lib${cosimlib}" : "/windows64/bin/${cosimlib}");

    my $top_level_name = '';

    # That could be from System Integrator in old flow or from calling generate_msim_system_tcl()
    generate_kernel_system_filelist() if ( $board_qsys );
    if ($sim_accurate_memory) {
      # Generate the fake_pll frequency as accurate memory does not run with 1 GHz
      generate_set_sim_freq_file();
    }

    # Create the msim_setup.tcl script for host to invoke
    _create_host_msim_setup_file(acl::File::abs_path($sim_dir));

    # Generate the modelsim compilation script. Compile is done in $sim_dir
    my $COMPILE_SCRIPT_FILE;
    open(COMPILE_SCRIPT_FILE, ">", $fname_compilescript) or acl::Common::mydie("Couldn't open $fname_compilescript for write!\n");
    print COMPILE_SCRIPT_FILE "onerror {abort all; exit -code 1;}\n";
    print COMPILE_SCRIPT_FILE "set VSIM_VERSION_STR \"$vsim_version_string\"\n";
    print COMPILE_SCRIPT_FILE "set QSYS_SIMDIR .\n";
    print COMPILE_SCRIPT_FILE "source mentor/msim_setup.tcl\n";
    print COMPILE_SCRIPT_FILE "set USER_DEFINED_VERILOG_COMPILE_OPTIONS \"+incdir+.";
    print COMPILE_SCRIPT_FILE " -suppress 2388" if (!$sim_enable_warnings);  # case:569080: duplicate definition
    print COMPILE_SCRIPT_FILE "\"\n";
    print COMPILE_SCRIPT_FILE "dev_com\n";  # case:532280: remove after incremental simulation compile works
    print COMPILE_SCRIPT_FILE "com\n";
    # OpenCL does not elaborate now, as it may hard code absolute pathnames, and this won't
    # work well on the farm, as they will be missing when we unpack the results.
    # HLS can elaborate for but will run into issue if folder is moved.
    if ($sim_enable_warnings) {
      print COMPILE_SCRIPT_FILE "if {\$tcl_platform(platform) == \"windows\"} {\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib \"\$::env(${sdk_root_name})/windows64/bin/${cosimlib}\"\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib [string map { \"\\\\\" \"/\"} \$fname_svlib]\n";
      print COMPILE_SCRIPT_FILE "} else {\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib \"\$::env(${sdk_root_name})/host/linux64/lib/lib${cosimlib}\"\n";
      print COMPILE_SCRIPT_FILE "}\n";
      print COMPILE_SCRIPT_FILE "set ELAB_OPTIONS \"";
      print COMPILE_SCRIPT_FILE "-dpioutoftheblue 1 -sv_lib \$fname_svlib";
      if (acl::Env::is_windows()) {
          print COMPILE_SCRIPT_FILE " -nodpiexports";
      }
      print COMPILE_SCRIPT_FILE ($sim_debug ? " -voptargs=+acc\"\n"
                                            : "\"\n");
      if ($top_level_name ne '') {
        # use user-defined the top level name.
        # Original simulation flow has top_level_name defined in msim_setup.tcl from QSys
        print COMPILE_SCRIPT_FILE "set TOP_LEVEL_NAME $top_level_name\n";
      }
      print COMPILE_SCRIPT_FILE "elab\n";
    }
    print COMPILE_SCRIPT_FILE "exit -code 0\n";
    close(COMPILE_SCRIPT_FILE);

    # Generate the run script. Elaboration is done at the parent level, i.e. $work_dir
    my $RUN_SCRIPT_FILE;
    open(RUN_SCRIPT_FILE, ">", $fname_runscript) or acl::Common::mydie("Couldn't open $fname_runscript for write!\n");
    print RUN_SCRIPT_FILE "onerror {abort all; puts stderr \"The simulation process encountered an error and has aborted.\"; exit -code 1;}\n";
    print RUN_SCRIPT_FILE "set VSIM_VERSION_STR \"$vsim_version_string\"\n";
    print RUN_SCRIPT_FILE "set QSYS_SIMDIR $sim_dir\n";
    # OpenCL specific as this is the Device MMD layer
    print RUN_SCRIPT_FILE "if {\$tcl_platform(platform) == \"windows\"} {\n";
    print RUN_SCRIPT_FILE "  set fname_svlib \"\$::env(${sdk_root_name})/windows64/bin/${cosimlib}\"\n";
    print RUN_SCRIPT_FILE "  set fname_svlib [string map { \"\\\\\" \"/\"} \$fname_svlib]\n";
    print RUN_SCRIPT_FILE "} else {\n";
    print RUN_SCRIPT_FILE "  set fname_svlib \"\$::env(${sdk_root_name})/host/linux64/lib/lib${cosimlib}\"\n";
    print RUN_SCRIPT_FILE "}\n";
    # end OpenCL specific
    print RUN_SCRIPT_FILE "source ${sim_dir}/mentor/msim_setup_host.tcl\n";
    print RUN_SCRIPT_FILE "# Suppress warnings from the std arithmetic libraries\n";
    print RUN_SCRIPT_FILE "set StdArithNoWarnings 1\n";
    # TODO: case:535241 OpenCL simulator vector_add example design Unknown formal identifier
    #       remove error suppression when all RTL generated is clean
    print RUN_SCRIPT_FILE "set ELAB_OPTIONS \"+nowarnTFMPC +nowarnBSOB ";
    print RUN_SCRIPT_FILE "-suppress 1130 -suppress 2732 -suppress 3584 ";
    print RUN_SCRIPT_FILE "-dpioutoftheblue 1 -sv_lib \$fname_svlib";
    if (acl::Env::is_windows()) {
        print RUN_SCRIPT_FILE " -nodpiexports";
    }
    print RUN_SCRIPT_FILE ($sim_debug ? " -voptargs=+acc\"\n"
                                      : "\"\n");
    if ($top_level_name ne '') {
      # use user-defined the top level name.
      # Original simulation flow has top_level_name defined in msim_setup.tcl from QSys
      print RUN_SCRIPT_FILE "set TOP_LEVEL_NAME $top_level_name\n";
    }
    print RUN_SCRIPT_FILE "elab\n";
    print RUN_SCRIPT_FILE "onfinish {stop}\n";
    print RUN_SCRIPT_FILE "quietly set StdArithNoWarnings 1\n";
    if ($sim_debug) {
      # (no ghdl) : highest simulation optimization
      # ghdl      : means log all
      # ghdl[=N]  : means log up to a certain level
      print RUN_SCRIPT_FILE "set WLFFilename \$env(WLF_NAME)\n";
      if (defined($sim_debug_depth)) {
        # currently only top level signals kernel_system_inst or specified RTL hierarchical depth, will be repurpose when productize
        # TODO: case:429038: Provide hardware simulation framework for library verification
        #        ghdl=1   : EFI  
        #        ghdl=2   : lsu's, iowr, iord
        if ($sim_debug_depth == 1) {
          print RUN_SCRIPT_FILE "log " . (($board_qsys) ? "${top_level_name}/" : "") . "$kernel_system_inst/*\n";
        }
        else {
          print RUN_SCRIPT_FILE "log -r * -depth $sim_debug_depth\n";
        }
      }
      else {
        print RUN_SCRIPT_FILE "log -r *\n";
      }
    }
    print RUN_SCRIPT_FILE "run -all\n";
    print RUN_SCRIPT_FILE "set failed [expr [coverage attribute -name TESTSTATUS -concise] > 1]\n";
    print RUN_SCRIPT_FILE "if {\${failed} != 0} { puts stderr \"The simulation process encountered an error and has been terminated.\"; }\n";
    print RUN_SCRIPT_FILE "exit -code \${failed}\n";
    close(RUN_SCRIPT_FILE);

    # Generate a script that we'll call to compile the design
    my $EXE_COM_FILE;
    open(EXE_COM_FILE, '>', "$sim_script_dir/$fname_exe_com_script") or acl::Common::mydie("Could not open file '$sim_script_dir/$fname_exe_com_script' $!");
    if (acl::Env::is_linux()) {
      print EXE_COM_FILE "#!/bin/sh\n";
      print EXE_COM_FILE "\n";
      print EXE_COM_FILE "# Identify the directory to run from\n";
      print EXE_COM_FILE "rundir=\$PWD\n";
      print EXE_COM_FILE "scripthome=\$(dirname \$0)\n";
      print EXE_COM_FILE "cd \${scripthome}\n";
      print EXE_COM_FILE "# Compile and elaborate the testbench\n";
      print EXE_COM_FILE "vsim -batch -do \"$sim_compile_script_name\"\n";
      print EXE_COM_FILE "retval=\$?\n";
      print EXE_COM_FILE "cd \${rundir}\n";
      print EXE_COM_FILE "exit \${retval}\n";
    } elsif (acl::Env::is_windows()) {
      print EXE_COM_FILE "set rundir=\%cd\%\n";
      print EXE_COM_FILE "set scripthome=\%\~dp0\n";
      print EXE_COM_FILE "cd %scripthome%\n";
      print EXE_COM_FILE "vsim -batch -do \"$sim_compile_script_name\"\n";
      print EXE_COM_FILE "set exitCode=%ERRORLEVEL%\n";
      print EXE_COM_FILE "cd %rundir%\n";
      print EXE_COM_FILE "exit /b %exitCode%\n";
    } else {
      acl::Common::mydie("Unsupported OS detected\n");
    }
    close(EXE_COM_FILE);
    if(acl::Env::is_linux()) {
      system("chmod +x $sim_script_dir/$fname_exe_com_script"); 
    }
    return 0;
}

# generate the include file matching in aoc_fake_pll.sv to overwrite predefined frequency
sub generate_set_sim_freq_file {
  # convert frequency to 2X clock period
  # 2x clock half period = 1/sim_kernel_clk_frequency(MHz) X 1E6 ps/us / 4
  my $clock2x_half_period = int(250000/$sim_kernel_clk_frequency);

  # variable name "clock2x_half_period_ps" must be consistent with opencl_sim/aoc_fake_pll IP
  # make sure the file name is same as aoc_fake_pll.sv

  # TODO: case:511709: Add aoc_fake_pll sim model to ip/board/bfm and add a flag to set fake PLL frequency at compile time
  # print out $sim_qsys_name/set_sim_freq.sv
  return;
}

# Write a verilog and vhdl filelist
# vhdl to be obseleted later when we generate only verilog
sub generate_kernel_system_filelist() {
  my @sv_list = ();
  my @vhdl_list = ();
  my @acl_lib_list = ();

  if ($kernel_system_qsys) {
    # kernel_system.tcl was invoked, qsys-generate files in ip/kernel_system and kernel_system
    # Parse the kernel_system/*.qip + ip/kernel_system/*.qip to get the kernel_system files
    my $path = "ip/kernel_system";
    append_rtl_filelist_recur($path, \@sv_list, \@vhdl_list, \@acl_lib_list);

    $path = "kernel_system";
    append_rtl_filelist_recur($path, \@sv_list, \@vhdl_list, \@acl_lib_list);
  }
  else {
    # Only OpenCL has QSys-less flow and places files in kernel_hdl, parse the kernel_system.qip
    push @sim_package, 'kernel_hdl';
    append_rtl_filelist_from_qip("kernel_system.qip", '.', \@sv_list, \@vhdl_list, \@acl_lib_list);
    if (-e "ip/kernel_mem") {
      # For Arria 10, get freeze wrapper and everything under
      append_rtl_filelist_recur("ip/kernel_mem", \@sv_list, \@vhdl_list, \@acl_lib_list);
    }
  }
  my $qsys_sim_tcl_script = "modelsim_files.tcl";
  # Not sure why when using Script to create it, it prepends qsys_name, but it doesn't do that when I use GUI
  my $sim_files_tcl_fname = "ip/${sim_qsys_name}/${sim_qsys_name}_${kernel_system_inst}/sim/common/".$qsys_sim_tcl_script;
  if (! -e $sim_files_tcl_fname) {
    $sim_files_tcl_fname = "ip/${sim_qsys_name}/${kernel_system_inst}/sim/common/".$sim_files_tcl_fname;
    if (! -e $sim_files_tcl_fname) {
      acl::Common::mydie("Cannot find $sim_files_tcl_fname.\n");
    }
  }
  # remove previous design files
  my @sim_script_text = ();
  my $in_design_lib_proc = 0;
  my $in_design_files_proc = 0;
  open(FH, "$sim_files_tcl_fname") or acl::Common::mydie("Can't open $sim_files_tcl_fname for read.\n");
  while (<FH>) {
    my $text =$_;
    if ($in_design_files_proc || $in_design_lib_proc) {
      if ($text =~ /^\s+(lappend.*kernel_system\.v|dict set)/) {
        next;  # do not append previous empty shell kernel_system.v
      }
      elsif ($text =~ /return/) {
        # reset variable
        $in_design_lib_proc = 0;
        $in_design_files_proc = 0;
      }
    }
    elsif ($text =~ /get_design_libraries/) {
      $in_design_lib_proc = 1;
    }
    elsif ($text =~ /get_design_files/) {
      $in_design_files_proc = 1;
    }
    push(@sim_script_text, $_);
  }
  close(FH);
  $in_design_lib_proc = 0;
  $in_design_files_proc = 0;
  # add acl_ip library and kernel_system files
  my $sdk_root_name = acl::Env::sdk_root_name();
  my $acl_ip_lib = "acl_ip";
  my $kernel_system_lib = $sim_qsys_name."_".$kernel_system_inst;  # name match with what QSys created
  my $qsys_compile_prefix = "    lappend design_files ";
  open(FH, ">$sim_files_tcl_fname") or acl::Common::mydie("Can't open $sim_files_tcl_fname for write.\n");
  for my $text (@sim_script_text) {
    if ($in_design_lib_proc) {
      print FH $text;  # prints initialization
      print FH "    dict set libraries $acl_ip_lib 1\n";
      print FH "    dict set libraries $kernel_system_lib 1\n";
      $in_design_lib_proc = 0;
      next;
    }
    elsif ($in_design_files_proc) {
      print FH $text;  # prints initialization, i.e. set design files [list]
      foreach my $acl_ip (@acl_lib_list) {
        if ($acl_ip =~ /\.vhd$/) {
          print FH "$qsys_compile_prefix\"vcom $acl_ip    -work $acl_ip_lib\"\n";
        }
        else {
          print FH "$qsys_compile_prefix\"vlog -sv \$USER_DEFINED_VERILOG_COMPILE_OPTIONS \$USER_DEFINED_COMPILE_OPTIONS +incdir+\$::env(${sdk_root_name})/ip $acl_ip    -work acl_ip\"\n";
        }
      }
      foreach my $sv_file (@sv_list) {
        print FH "$qsys_compile_prefix\"vlog -sv \$USER_DEFINED_VERILOG_COMPILE_OPTIONS $sv_file    -work $kernel_system_lib\"\n";
      }
      foreach my $vhdl_file (@vhdl_list) {
        print FH "$qsys_compile_prefix\"vcom \$USER_DEFINED_VHDL_COMPILE_OPTIONS $vhdl_file    -work $kernel_system_lib\"\n";
      }
      $in_design_files_proc = 0;
      next;
    }
    elsif ($text =~ /get_design_libraries/) {
      $in_design_lib_proc = 1;
    }
    elsif ($text =~ /get_design_files/) {
      $in_design_files_proc = 1;
    }
    print FH $text;
  }
  close(FH);
  return;
}

# recursively and find all the qip files
sub append_rtl_filelist_recur($$$$) {
  my ($path, $sv_list, $vhdl_list, $acl_lib_list) = @_;

  # resursively find all the qip files in the folder
  opendir(DIR, $path) or acl::Common::mydie("Cannot open $path\n");
  my @files = readdir(DIR);
  closedir(DIR);
  foreach my $file (@files) {
    next if ($file =~ /^\.\.?$/);
    my $filepath = $path."/".$file;
    
    if ($file =~ /\.qip$/) {
      my $qip_file = $path."/".$file;
      append_rtl_filelist_from_qip($qip_file, $path, $sv_list, $vhdl_list, $acl_lib_list);
    }
    elsif (-d $filepath) {
      append_rtl_filelist_recur($filepath, $sv_list, $vhdl_list, $acl_lib_list);
    }
  }
}

sub append_rtl_filelist_from_qip($$$$$) {
  my ($qip_file, $path, $sv_list, $vhdl_list, $acl_lib_list) = @_;
  my $verbose = acl::Common::get_verbose();

  open(FILE, "<$qip_file") or acl::Common::mydie("Can't open $qip_file for read\n");
  while(<FILE>) {
    my $line = $_;
    # TODO: add library during compilation - right now, just compile to work lib
    if ($line =~ /(VERILOG_FILE|VHDL_FILE|MISC_FILE).*qip_path.*\"(.*)\"/) {
      my $language = $1;
      my $filepath = $2;
      if ($language eq "MISC_FILE") {
        # ignore Header files, .ip files and etc
        if ($filepath =~ /hex/) {
          # copy hex files over to $
          my $hex_file = acl::File::mybasename($filepath);
          acl::File::copy($path."/".$filepath, $hex_file);
          push @sim_package, $hex_file;
        }
        next;
      }
      elsif ($filepath =~ /\$::env\S+\).*/) {
        # Library file. Modelsim is already tcl based, so path is identical
        push @{$acl_lib_list}, $filepath;
        next;
      }
      # a Verilog/Systemverilog or VHDL file set pointer to the right list to populate
      my $list_ptr;
      $list_ptr = ($language eq "VERILOG_FILE") ? $sv_list : $vhdl_list;
      # add the absolute path
      push @{$list_ptr}, $path."/".$filepath;
      # add files that are in workdir
      push @sim_package, $filepath if ($filepath !~ /\// && $path eq ".");
    }
  }
  close(FILE);
}

=head2 compile_opencl_simulator($fulllog, $work_dir)

Calls com function in msim_setup after simulation scripts is generated. Returns 0 when successed.
Prerequisite to calling this function is setup the simulation directory variables, i.e. sim_dir, sim_script_dir, kernel_system_inst and etc.

=cut

sub compile_opencl_simulator($$) {
  my ($fulllog, $work_dir) = @_;
  my $verbose = acl::Common::get_verbose();
  my $quiet_mode = acl::Common::get_quiet_mode();

  # copy the relevant files over
  opencl_sim_copy_files($work_dir);

  # include the correct directory for package
  push @sim_package, $sim_qsys_name;
  push @sim_package, "kernel_system" if (! $board_qsys);

  # Clean up for simulation, don't copy the RTL in the ip folder as they are pertaining to board BSP and not simulator
  # some of the files in the folder has long file name and cause Windows host execution failure during unpacking the RTL from aocx
  my @board_dirs = acl::File::simple_glob( "ip/*" );
  foreach my $d (@board_dirs) {
    if ($d !~ /\/(${sim_qsys_name}|kernel.*|\S+\.(sv|v|vhd))$/) { # these are sub dir in ip that's needed for sim
      acl::File::remove_tree($d);
    }
  }
  # Queries for Modelsim licence and creates compile and run the script
  my $return_status = generate_simulation_scripts();
  print "Compiling simulation...\n" if $verbose && !$quiet_mode;
  my $sim_script_path = acl::File::abs_path($sim_script_dir);
  chdir $sim_script_path;
  $return_status == 0 or acl::Common::mydie("Error accessing ModelSim.  Please ensure you have a valid ModelSim installation on your path.\n" .
                                     "       Check your ModelSim installation with \"vsim -version\" \n");
  my $msim_compile_script = $sim_compile_script_name;
  if (! -e $msim_compile_script) {
    acl::Common::mydie("Cannot find modelsim compile script $msim_compile_script.\n");
  }
  $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'compiling-simulation, ', 'stdout' => 'msim-compile.tmp', 'stderr' => '&STDOUT'},
      "vsim -batch -do \"$msim_compile_script\"");
  chdir $work_dir;
  acl::Common::move_to_log("!========== msim-compile ==========","${sim_script_path}/msim-compile.tmp",$fulllog);
  $return_status == 0 or acl::Common::mydie("Simulation compile FAILED.\nRefer to ".acl::File::mybasename($work_dir)."/$fulllog for details.\n");
  print "Simulation generation done!\n" unless $quiet_mode;
  # sim dir need to be placed in aocx for aoc_msim_device to find the right location
  my $sim_path_filename = get_sim_options();
  open SIMDIR_FH, ">$sim_path_filename" or acl::Common::mydie("Couldn't open $sim_path_filename for write.\n");
  print SIMDIR_FH $sim_script_dir."\n";
  print SIMDIR_FH $sim_accurate_memory."\n";
  close SIMDIR_FH;

  return 0;
}

sub opencl_sim_copy_files($) {
  my $work_dir = shift;
  # Do nothing if QSys generates everything - backward compatible
  return if !$board_qsys;
  # Only copy over hex file if vendor provides accurate memory model or less-QSys flow
  my @qsys_sim_gen_dirs= ($sim_qsys_name, 'ip');
  foreach my $d (@qsys_sim_gen_dirs) {
    acl::File::copy_tree($qsys_temp_dir_path."/".$d, $work_dir);
  }
  # Copy hex files (for ROM's) by system integrator into simulation directory
  acl::File::copy("*.hex", $sim_script_dir);
}

# Set the sim_dir for QSYS_SIMDIR and sim_script_dir for output scripts dir
sub _setup_sim_directory {
  # Do nothing as the default is for mpsim
  if ($sim_accurate_memory) {
    # TODO: case: 516209: Handle board simulation flow in board_spec.xml
    #  currently hardcoded sim dir, sim script dir, top level files, top level name for s10gx_ea_htile
    $sim_qsys_name = "sim";
    # some basic error checking before continuing
    if (!(-d $sim_qsys_name)) {
      acl::Common::mydie("Accurate memory simulation folder $sim_qsys_name does not exist!\n");
    }
    $sim_dir = $sim_qsys_name."/board_sim/sim";
    $sim_script_dir = $sim_dir;
  }
}

=head2 opencl_create_sim_system($board_variant, $work_dir)

Create the OpenCL simulation system by calling QSys and precompile common library.
This is to create the simulation harness with an empty kernel for QSys-less flow

=cut

sub opencl_create_sim_system($$$$) {
  my ($board_variant, $less_qsys, $work_dir_no_base, $bcxml_file) = @_;
  my $verbose = acl::Common::get_verbose();
  # set global variables
  $board_qsys = $less_qsys;  # skip_qsys == less_qsys == board_qsys
  my $fulllog = "qsys_msim_gen.log";

  my $acl_board_hw_path = acl::AOCDriverCommon::get_acl_board_hw_path($board_variant);
  my $board_spec_xml = acl::AOCDriverCommon::find_board_spec($acl_board_hw_path);
  my $devicemodel = uc acl::Env::aocl_boardspec( "$board_spec_xml", "devicemodel");
  # Remove trailing '_.*' from devicemodel: a10_sdk -> a10
  ($devicemodel) = $devicemodel =~ /(.*)_.*/;
  my $devicefamily = acl::AOCDriverCommon::device_get_family_no_normalization($devicemodel);
  my $has_snoop =  acl::Env::aocl_boardspec( "$board_spec_xml", "has_snoop");

  if ($board_qsys == 0) {
    # flow for 18.0 and 18.1, kept for IO channel
    set_sim_dir_path(".");  # set qsys directory path same as ".", qsys directory name as work directory
    $fulllog =  "ipgen.tmp";
    _opencl_sim_generate_system($devicefamily, $acl_board_hw_path, $has_snoop, $bcxml_file, $fulllog);
    _setup_sim_directory();
    return;
  }
  # check for hidden flag and options for -sim-input-dir
  if (defined($qsys_temp_dir_path)) {
    print "Found previous compiled testbench in $qsys_temp_dir_path. Skipping testbench generation.\n" if $verbose;
    _setup_sim_directory();
    return;
  }
  # initialize simulation qsys directory with default directory name when user did not supply one
  $qsys_temp_dir_path = $work_dir_no_base.$qsys_temp_dir;
  if (!$sim_accurate_memory) {
    acl::File::remove_tree($qsys_temp_dir_path) if (-e $qsys_temp_dir_path);
    acl::File::make_path($qsys_temp_dir_path) or acl::Common::mydie("Cannot create temporary simulation directory $qsys_temp_dir: $!");
    acl::Common::mydie("Cannot find $bcxml_file: $!") if (!(-e $bcxml_file));
    chdir $qsys_temp_dir_path or acl::Common::mydie("Cannot change dir into $qsys_temp_dir_path: $!");
    _opencl_sim_generate_system($devicefamily, $acl_board_hw_path, $has_snoop, $bcxml_file, $fulllog);
    my $orig_dir = acl::Common::get_original_dir();
    chdir $orig_dir or acl::Common::mydie("Cannot change back into directory $orig_dir: $!");
  }
  _setup_sim_directory();
}

# Create a simulation system at compile time, copy over the top level testbench
sub _opencl_sim_generate_system($$$$$) {
  my ($devicefamily, $acl_board_hw_path, $use_snoop, $bcxml_file, $fulllog) = @_;
  my $verbose = acl::Common::get_verbose();
  my $quiet_mode = acl::Common::get_quiet_mode();
  my $sopc_builder_cmd = "qsys-script";
  my $ip_gen_cmd = 'qsys-generate';

  # Create the complete simulation system for less accurate memory model or not previous created folder
  print "Creating simulation system...\n" if $verbose && !$quiet_mode;
  my $qsys_quartus_project = "--quartus-project=none";  # only supports >=18.0 pro version
  if ($board_qsys) {
    # Less accurate memory model or QSys flow uses to stitch together the whole system
    acl::File::copy( "$acl_board_hw_path/hw_iface.iipx", "hw_iface.iipx" );
    acl::File::copy( "$acl_board_hw_path/sw_iface.iipx", "sw_iface.iipx" );
    acl::File::copy( "$acl_board_hw_path/iface.ipx", "iface.ipx" );
    acl::Env::create_opencl_ipx(".");
    # TODO: case:576491 Use System Integrator to generate empty_kernel_hw.tcl
    #       temporary workaround parse .bc.xml and copy over example kernel system hw tcl
    _create_empty_kernel_system();
  }
  # TODO: cache some information about boardspec.xml to the folder so the simulation framework matches later
  my $generate_system_script = 'aoc_create_msim_system.tcl';
  _generate_msim_system_wrapper_tcl($devicefamily, $use_snoop, $bcxml_file, $generate_system_script);
  my $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'qsys-script-simulation, ', 'stdout' => 'qsys-script.tmp', 'stderr' => '&STDOUT'},
    "$sopc_builder_cmd --script=$generate_system_script $qsys_quartus_project");
  acl::Common::move_to_log("!========== create-simulation ==========","qsys-script.tmp",$fulllog);
  $return_status == 0 or acl::Common::mydie("Simulation system creation FAILED.\nRefer to $qsys_temp_dir_path/$fulllog for details.\n");
  # Generate the simulatable HDL
  print "Generating simulation system...\n" if $verbose && !$quiet_mode;
  $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'qsys-generate-simulation, ', 'stdout' => 'ipgen.tmp', 'stderr' => '&STDOUT'},
    "$ip_gen_cmd --family=\"$devicefamily\" ${sim_qsys_name}.qsys --simulation $qsys_quartus_project --jvm-max-heap-size=3G --clear-output-directory");
  $return_status == 0 or acl::Common::mydie("Simulation system generation FAILED.\nRefer to $qsys_temp_dir_path/$fulllog for details.\n");
}

sub _create_empty_kernel_system() {
  # TODO: call system integrator to generate the empty_kernel_system_hw.tcl file
  my $empty_ks_script = acl::Env::sdk_root()."/share/lib/opencl_sim/empty_kernel_system_hw.tcl";
  my $kernel_system_rtl = acl::Env::sdk_root()."/share/lib/opencl_sim/kernel_system.v";
  acl::File::copy($empty_ks_script, "empty_kernel_system_hw.tcl");
  acl::File::copy($kernel_system_rtl, "kernel_system.v") if (! (-e "kernel_system.v"));  # don't over existing one
}

sub _generate_msim_system_wrapper_tcl($$$$) {
  my ($devicefamily, $use_snoop, $bcxml_file, $outfile) = @_;
  my $qsys_generate_system_script = acl::Env::sdk_root()."/share/lib/tcl/aoc_sim_generate_qsys.tcl";
  # TODO: case:520397 Enable Interleave slave bfm memory
  #       open board spec and get memory size, interleaving, and interleaving size if applicable
  #       set the variables then source the script
  my $host_to_dev_width = 0;
  my $dev_to_host_width = 0;
  open(BCXML_FH, $bcxml_file) or acl::Common::mydie("Couldn't open ${bcxml_file} for write! : $!\n");
  while (<BCXML_FH>) {
    my $line = $_;
    if ($line =~ /<INTERFACE port.*chan_id=\S+host/) {
      if ($line =~ /width="(\d+)".*optype="read"/) {
        $host_to_dev_width = $1;
      }
      elsif ($line =~ /width="(\d+)".*optype="write"/) {
        $dev_to_host_width = $1;
      }
      # else error out!
    }
  }
  close BCXML_FH;
  open(TCL, ">$outfile") or acl::Common::mydie("Couldn't open ${outfile} for write! : $!\n");
  print TCL "set INCL_KERNEL_SYSTEM 1\n" if (! $board_qsys);
  print TCL "set USE_SNOOP 1\n" if ($use_snoop);
  print TCL "set HOST_TO_DEV_READ_WIDTH ${host_to_dev_width}\n";
  print TCL "set DEV_TO_HOST_WRITE_WIDTH ${dev_to_host_width}\n";
  print TCL "set GLB_MEM_AV_WAITREQUEST_ALLOWANCE 6\n" if ($devicefamily =~ /Stratix 10/);
  print TCL "source $qsys_generate_system_script\n";
  close(TCL);
}

=head2 write_sim_repackage_script($work_dir)

Write out a repackage script for user to simply modify tb or run script without invoking compliation

=cut

sub write_sim_repackage_script($) {
  my $pkg_filepath = shift;
  my $sim_repkg_filename = (acl::Env::is_windows()) ? "sim_repackage.cmd" : "sim_repackage.sh";
  open SIM_REPKG_FH, ">$sim_repkg_filename" or acl::Common::mydie("Couldn't open $sim_repkg_filename for write.\n");
  print SIM_REPKG_FH "call " if (acl::Env::is_windows());
  print SIM_REPKG_FH "${sim_script_dir}/${fname_exe_com_script} > recompile.log\n";
  my $pkg_string = join(" ", get_sim_package())." ".get_sim_options();
  print SIM_REPKG_FH "aocl binedit fpga-sim.bin package sys_description.hex $pkg_string\n";
  print SIM_REPKG_FH "aocl binedit $pkg_filepath set .acl.fpga.bin fpga-sim.bin\n";
  if (acl::Env::is_windows()) {
    print SIM_REPKG_FH "del fpga-sim.bin";
  }
  else {
    print SIM_REPKG_FH "rm -f fpga-sim.bin";
  }
  close SIM_REPKG_FH;
}

1;
